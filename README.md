### calculation（自动生成四则运算程序Python版）

### PSP表格
| PSP2.1 | Personal Software Process Stages | 预估耗时（分钟） | 实际耗时（分钟） |
| --------------- | --------------- | --------------- | --------------- |
| Planning | 计划 | 70 | 75 |
| · Estimate | · 估计这个任务需要多少时间 | 20 | 20 |
| Development | 开发 | 700 | 850 |
| · Analysis | · 需求分析 (包括学习新技术) | 80 | 80 |
| · Design Spec | · 生成设计文档 | 60 | 60 |
| · Design Review | · 设计复审 | 60 | 90 |
| · Coding Standard | · 代码规范 (为目前的开发制定合适的规范) | 15 | 15 |
| · Design | · 具体设计 | 100 | 120 |
| · Coding | · 具体编码 | 360 | 400 |
| · Code Review | · 代码复审 | 60 | 60 |
| · Test | · 测试（自我测试，修改代码，提交修改） | 50 | 60 |
| Reporting | 报告 | 60 | 60 |
| · Test Report | · 测试报告 | 30 | 30 |
| · Size Measurement | · 计算工作量 | 20 | 20 |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划 | 60 | 60 |
| Total | · 合计 | 1745 | 2000 |

### 性能分析模块和测试

#### 1.CPU占用图
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012172443889-1893866242.png)

#### 2.各个模块性能分析及其所需要的时间详细分析图
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012172523756-874934159.png)

### 设计实现过程流程图

#### 1.检查式子是否重复流程图
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012172914722-1751764048.png)
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012172920152-299758920.png)

#### 2.负责四则运算和转换类
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012173209122-1516907644.png)

#### 3.负责生成题库类
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012173345757-906380462.png)
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012173406421-1960170863.png)

#### 4.主函数类
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012173447438-1552838065.png)

### 单元测试展示代码

#### 1.生成题库，参数在命令行中展示，-r 为最大自然数范围，-n为生成题目道数
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012173738702-1647704624.png)

#### 2.在本地myapp.py中生成了Exercises.txt和Answers.txt文件
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012174000468-304224442.png)

#### 3.题库文件
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012174034539-1981298815.png)

#### 4.答案文件
![](https://img2020.cnblogs.com/blog/1591211/202010/1591211-20201012174016540-1592239028.png)

### 生成题库原理和流程

- 1.什么是逆波兰算法？
逆波兰表达式又叫做后缀表达式。逆波兰表示法是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法。后来,人们就把用这种表示法写出的表达式称作“逆波兰表达式”。**逆波兰表达式把运算量写在前面,把算符写在后面**。

- 2。该算法的具体实现步骤

(1)、首先构造一个运算符栈，此运算符在栈内遵循越往栈顶优先级越高的原则。

(2)、读入一个用中缀表示的简单算术表达式，为方便起见，设该简单算术表达式的右端多加上了优先级最低的特殊符号“#”。

(3)、从左至右扫描该算术表达式，从第一个字符开始判断，如果该字符是数字，则分析到该数字串的结束并将该数字串直接输出。

(4)、如果不是数字，该字符则是运算符，此时需比较优先关系。具体做法是：将该字符与运算符栈顶的运算符的优先关系相比较。如果该字符优先关系高于此运算符栈顶的运算符，则将该运算符入栈。若不是的话，则将栈顶的运算符从栈中弹出，直到栈项运算符的优先级低于当前运算符，将该字符入栈。

(5)、重复步骤1～2，直至扫描完整个简单算术表达式，确定所有字符都得到正确处理，便可以将中缀式表示的简单算术表达式转化为逆波兰表示的简单算术表达式。
